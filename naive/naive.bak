#lang racket

;world struct
(struct world
  (parent
   env
   [children #:mutable]
   [dirty #:mutable])
  #:transparent)


;thisworld and sprout
(define thisworld (world #f (make-hash) '() #f))
(define (sprout w)
  (define child (world w (make-hash) '() #f))
  (set-world-children! w (cons child (world-children w)))
  child)
(define (commit w)
  (when (not (world-dirty w))
    (hash-for-each (world-env w)
                   (lambda (var val)
                     (hash-set! (world-env (world-parent w)) var val)))))
  
(define globalworld thisworld)

(define-syntax-rule (in world expr)
  (let ((prev-global globalworld))
    (set! globalworld world)
    (define result expr)
    (set! globalworld prev-global)
    result))

;Look for the variable in the environment of the world and its parents
(define (check-env w var)
  (define par (world-parent w))
  (let ((val (hash-ref (world-env w) var #f)))
    (if val val
        (if par
            (check-env par var)
            (display "not found")))))

;find a variable in a world, if found. remember in the environment
(define (lookup var)
  (define val (check-env globalworld var))
  (hash-set! (world-env globalworld) var val)
  val)

;wdefine defines the variable and sets it in its environment
(define-syntax-rule (wdefine EXPR REST)
  (begin
    ;(define EXPR REST) ;not nessessary?
    (hash-set! (world-env globalworld) 'EXPR REST)))


;set! in a specific world, searches if one of children uses the variable. if so, set its dirty bit to #t
(define-syntax-rule (wset! EXPR REST)
  (begin
    ;(set! EXPR REST) ;not nessessary?
    (for-each (lambda (w)
                (when (hash-ref (world-env w) 'EXPR)
                  (set-world-dirty! w #t)))
              (world-children globalworld))
    (hash-set! (world-env globalworld) 'EXPR REST)))

;exception handling example
(define (do-it x y)
  (try-catch
   (lambda()
     (try-catch
      (lambda ()
        (logarithm x y))
      (lambda (exception)
        (eq? exception 'division-by-zero))
      (lambda (exception)
        (display "x/0"))))
   (lambda (exception)
     (eq? exception 'negative-log))
   (lambda(exception)
     (display "log(-x)"))))

(define (divide x y)
  (wset! testers "changed")
  (if (= y 0)
      (throw 'division-by-zero)
      (/ x y)))
(define (logarithm x y)
  (if (or (<= x 0)
          (<= y 0))
      (throw 'negative-log)
      (divide (log x)(log y))))

(define (*throw* exception)
  (displayln (format "No exception handler: ~a" exception)))
(define (throw exception)
  (*throw* exception))

(define (try-catch try-lambda filter handler)
  (call/cc
   (lambda (cont)
     (define keep *throw*)
     (define child (sprout thisworld))
     (set! *throw* (lambda (exception)
                     (set! *throw* keep)
                     (if (filter exception)
                         (cont (handler exception))
                         (throw exception))))
     (define result (in child (try-lambda)))
     (commit child)
     (set! *throw* keep)
     result)))


(in thisworld (wdefine testers "wazgood"))
(world-env thisworld)
(do-it 5 10)
(world-env thisworld)
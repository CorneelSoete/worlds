#lang racket

;world struct
(struct world
  (parent
   env)
  #:transparent)

(struct env
  ([read #:mutable]
   [wrote #:mutable])
  #:transparent)
(define (wrote w)
  (env-wrote (world-env w)))
(define (read w)
  (env-read (world-env w)))


(define (empty-env)
  (env (make-hash) (make-hash)))
(define (write! w var val)
  (hash-set! (wrote w) var val))
(define (wrote? w var)
  (hash-ref (wrote w) var #f))
(define (read! w var val)
  (hash-set! (read w) var val))
(define (read? w var)
  (hash-ref (read w) var #f))

;thisworld and sprout
(define thisworld (world #f (empty-env)))
(define globalworld thisworld)

(define (sprout w)
  (define child (world w (empty-env)))
  child)

(define (commit w)
  (let ((true? #t)
        (par (world-parent w)))
    (when par
      (begin
        (hash-for-each (read w)
                       (lambda (var val)
                         (when (not (or (eq? val (check-envs (world-parent w) var))
                                        (eq? 'notfound (check-envs (world-parent w) var))))
                           (set! true? #f))))
        (if true?
            (begin
              (hash-for-each (wrote w)
                             (lambda (var val)
                               (write! (world-parent w) var val)))
              (hash-for-each (read w)
                             (lambda (var val)
                               (read! (world-parent w) var val))))
            (error "illegal commit exception"))))))

;since this is a macro but it has to change the global, we have to define a function which will do the set! in its place
(define-syntax-rule (in world expr ...)
  (let ((prev-global globalworld))
    (replace-global world)
    (define result (begin expr ...))
    (replace-global prev-global)
    result))
(define (replace-global newglobal)
  (set! globalworld newglobal))

;Look for the variable in the environment of the world and its parents
(define (check-env w var)
  (let ((wrote (wrote? w var)))
    (if wrote wrote
        (read? w var))))

(define (check-envs w var)
  (define par (world-parent w))
  (let ((val (check-env w var)))
    (if val val
        (if par
            (check-envs par var)
            'notfound))))
  

;find a variable in a world, if found. remember in the environment
(define (lookup var)
  (let ((val (check-env globalworld var))
        (par (world-parent globalworld)))
    (if val val
        (begin
          (if par
              (set! val (check-envs (world-parent globalworld) var))
              (set! val 'notfound))
          (if (eq? val 'notfound)
              (displayln (format "var '~a' not found" var))
              (begin (read! globalworld var val)
                     val))))))

;wdefine defines the variable and sets it in its environment
(define-syntax-rule (wdefine* VAR VAL)
  (hash-set! (env-wrote (world-env globalworld)) 'VAR VAL))

(define-syntax (wdefine VAR)
  (syntax-case VAR ()
    [( _ (a b ...) ... c) #'(write! globalworld 'a ... (lambda (b ...) c) ...)]
    [(_ a b) #'(write! globalworld 'a b)]))

;set! in a specific world, searches if one of children uses the variable. if so, set its dirty bit to #t
(define-syntax-rule (wset! VAR VAL)
  (write! globalworld 'VAR VAL))

(provide (all-from-out racket)
         in          sprout        commit
         lookup      wdefine       wset!
         thisworld   world-env
         replace-global
         world world-parent env ;added for testing purposes
         )